package ctrmap.renderer.util.texture.compressors;

import ctrmap.renderer.util.texture.TextureCodec;
import static ctrmap.renderer.util.texture.TextureCodec.*;

/*
https://github.com/hglm/detex

Copyright (c) 2015 Harm Hanemaaijer <fgenfb@yahoo.com>
Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted, provided that the above
copyright notice and this permission notice appear in all copies.
THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
public class ETC2 {

	public static final int DETEX_MODE_MASK_ETC_INDIVIDUAL = 0x1;
	public static final int DETEX_MODE_MASK_ETC_DIFFERENTIAL = 0x2;
	public static final int DETEX_MODE_MASK_ETC_T = 0x4;
	public static final int DETEX_MODE_MASK_ETC_H = 0x8;
	public static final int DETEX_MODE_MASK_ETC_PLANAR = 0x10;
	public static final int DETEX_MODE_MASK_ALL_MODES_ETC1 = 0x3;
	public static final int DETEX_MODE_MASK_ALL_MODES_ETC2 = 0x1F;
	public static final int DETEX_MODE_MASK_ALL_MODES_ETC2_PUNCHTHROUGH = 0x1E;
	public static final int DETEX_MODE_MASK_ALL_MODES_BPTC = 0xFF;
	public static final int DETEX_MODE_MASK_ALL_MODES_BPTC_FLOAT = 0x3FFF;
	public static final int DETEX_MODE_MASK_ALL = 0xFFFFFFFF;

	/**
	 * Function returns false (invalid block) when the compressed block is in a format not allowed to be generated by an encoder.
	 */
	public static final int DETEX_DECOMPRESS_FLAG_ENCODE = 0x1;
	/**
	 * For compression formats that have opaque and non-opaque modes, return false (invalid block) when the compressed block is encoded using a non-opaque mode.
	 */
	public static final int DETEX_DECOMPRESS_FLAG_OPAQUE_ONLY = 0x2;
	/**
	 * For compression formats that have opaque and non-opaque modes, return false (invalid block) when the compressed block is encoded using an opaque mode.
	 */
	public static final int DETEX_DECOMPRESS_FLAG_NON_OPAQUE_ONLY = 0x4;

	private static final int[] complement3bitshifted_table = new int[]{
		0, 8, 16, 24, -32, -24, -16, -8
	};

	private static final int[][] ETC1_LUT = new int[][]{
		{2, 8, -2, -8},
		{5, 17, -5, -17},
		{9, 29, -9, -29},
		{13, 42, -13, -42},
		{18, 60, -18, -60},
		{24, 80, -24, -80},
		{33, 106, -33, -106},
		{47, 183, -47, -183}
	};

// This function calculates the 3-bit complement value in the range -4 to 3 of a three bit
// representation. The result is arithmetically shifted 3 places to the left before returning.
	public static int complement3bitshifted(int x) {
		return complement3bitshifted_table[x];
	}

	public static int complement3bitshifted_slow(int x) {
		if ((x & 4) != 0) {
			return ((x & 3) - 4) << 3;	// Note: shift is arithmetic.
		}
		return x << 3;
	}

	public static int complement3bit(int x) {
		if ((x & 4) != 0) {
			return ((x & 3) - 4);
		}
		return x;
	}

	public static int getPixelIndexWord(byte[] bitstring, int bitstring_offs) {
		return ((bitstring[bitstring_offs + 4] & 0xFF) << 24) | ((bitstring[bitstring_offs + 5] & 0xFF) << 16)
			| ((bitstring[bitstring_offs + 6] & 0xFF) << 8) | (bitstring[bitstring_offs + 7] & 0xFF);
	}

	public static int getPixelIndex(int i, int pixel_index_word) {
		int pixel_index = (((pixel_index_word & (1 << i)) >> i) & 1)
			| (((pixel_index_word & (0x10000 << i)) >> (16 + i - 1)) & 2);
		return pixel_index;
	}

	private static void decodeRGBPixelETC1(int i, int pixel_index_word, int table_codeword, int[] base_color_subblock, byte[] pixel_buffer, int pbuf_offs, boolean alpha) {
		int r, g, b;
		int modifier = ETC1_LUT[table_codeword][getPixelIndex(i, pixel_index_word)];
		r = saturate(base_color_subblock[0] + modifier);
		g = saturate(base_color_subblock[1] + modifier);
		b = saturate(base_color_subblock[2] + modifier);

		int off = pbuf_offs + ((i & 3) * 4 + ((i & 12) >> 2)) * (alpha ? 4 : 3);

		pixel_buffer[off + 0] = (byte) r;
		pixel_buffer[off + 1] = (byte) g;
		pixel_buffer[off + 2] = (byte) b;

		if (alpha) {
			pixel_buffer[off + 3] = (byte) 0xFF;
		}
	}

	/**
	 * Decompress a 64-bit 4x4 pixel texture block compressed using the ETC1 format.
	 *
	 * @param bitstring Byte array containing the texture block.
	 * @param bitstring_offs Offset of the texture block in the array.
	 * @param mode_mask Mask of enabled decoding modes.
	 * @param flags Detex decompression cap flags.
	 * @param pixel_buffer Output RGBA buffer.
	 * @param pbuf_offs Offset of the resulting block in the RGBA buffer.
	 * @param alpha True if the target buffer is a 4BPP RGBA image instead of 3BPP RGB.
	 *
	 * @return True if the entire block was successfully decoded.
	 */
	public static boolean detexDecompressBlockETC1(byte[] bitstring, int bitstring_offs, int mode_mask, int flags, byte[] pixel_buffer, int pbuf_offs, boolean alpha) {
		boolean differential_mode = (bitstring[bitstring_offs + 3] & 2) != 0;
		if (differential_mode) {
			if ((mode_mask & DETEX_MODE_MASK_ETC_DIFFERENTIAL) == 0) {
				return false;
			}
		} else if ((mode_mask & DETEX_MODE_MASK_ETC_INDIVIDUAL) == 0) {
			return false;
		}
		boolean flipbit = (bitstring[bitstring_offs + 3] & 1) != 0;
		int[] base_color_subblock1 = new int[3];
		int[] base_color_subblock2 = new int[3];
		if (differential_mode) {
			base_color_subblock1[0] = (bitstring[bitstring_offs + 0] & 0xF8);
			base_color_subblock1[0] |= ((base_color_subblock1[0] & 224) >> 5);
			base_color_subblock1[1] = (bitstring[bitstring_offs + 1] & 0xF8);
			base_color_subblock1[1] |= (base_color_subblock1[1] & 224) >> 5;
			base_color_subblock1[2] = (bitstring[bitstring_offs + 2] & 0xF8);
			base_color_subblock1[2] |= (base_color_subblock1[2] & 224) >> 5;
			base_color_subblock2[0] = (bitstring[bitstring_offs + 0] & 0xF8);			// 5 highest order bits.
			base_color_subblock2[0] += complement3bitshifted(bitstring[bitstring_offs + 0] & 7);	// Add difference.
			if ((base_color_subblock2[0] & 0xFF07) != 0) // Check for overflow.
			{
				return false;
			}
			base_color_subblock2[0] |= (base_color_subblock2[0] & 224) >> 5;	// Replicate.
			base_color_subblock2[1] = (bitstring[bitstring_offs + 1] & 0xF8);
			base_color_subblock2[1] += complement3bitshifted(bitstring[bitstring_offs + 1] & 7);
			if ((base_color_subblock2[1] & 0xFF07) != 0) {
				return false;
			}
			base_color_subblock2[1] |= (base_color_subblock2[1] & 224) >> 5;
			base_color_subblock2[2] = (bitstring[bitstring_offs + 2] & 0xF8);
			base_color_subblock2[2] += complement3bitshifted(bitstring[bitstring_offs + 2] & 7);
			if ((base_color_subblock2[2] & 0xFF07) != 0) {
				return false;
			}
			base_color_subblock2[2] |= (base_color_subblock2[2] & 224) >> 5;
		} else {
			base_color_subblock1[0] = (bitstring[bitstring_offs + 0] & 0xF0);
			base_color_subblock1[0] |= base_color_subblock1[0] >> 4;
			base_color_subblock1[1] = (bitstring[bitstring_offs + 1] & 0xF0);
			base_color_subblock1[1] |= base_color_subblock1[1] >> 4;
			base_color_subblock1[2] = (bitstring[bitstring_offs + 2] & 0xF0);
			base_color_subblock1[2] |= base_color_subblock1[2] >> 4;
			base_color_subblock2[0] = (bitstring[bitstring_offs + 0] & 0x0F);
			base_color_subblock2[0] |= base_color_subblock2[0] << 4;
			base_color_subblock2[1] = (bitstring[bitstring_offs + 1] & 0x0F);
			base_color_subblock2[1] |= base_color_subblock2[1] << 4;
			base_color_subblock2[2] = (bitstring[bitstring_offs + 2] & 0x0F);
			base_color_subblock2[2] |= base_color_subblock2[2] << 4;
		}
		int table_codeword1 = (bitstring[bitstring_offs + 3] & 224) >> 5;
		int table_codeword2 = (bitstring[bitstring_offs + 3] & 28) >> 2;
		int pixel_index_word = getPixelIndexWord(bitstring, bitstring_offs);
		if (!flipbit) {
			decodeRGBPixelETC1(0, pixel_index_word, table_codeword1, base_color_subblock1, pixel_buffer, pbuf_offs, alpha);
			decodeRGBPixelETC1(1, pixel_index_word, table_codeword1, base_color_subblock1, pixel_buffer, pbuf_offs, alpha);
			decodeRGBPixelETC1(2, pixel_index_word, table_codeword1, base_color_subblock1, pixel_buffer, pbuf_offs, alpha);
			decodeRGBPixelETC1(3, pixel_index_word, table_codeword1, base_color_subblock1, pixel_buffer, pbuf_offs, alpha);
			decodeRGBPixelETC1(4, pixel_index_word, table_codeword1, base_color_subblock1, pixel_buffer, pbuf_offs, alpha);
			decodeRGBPixelETC1(5, pixel_index_word, table_codeword1, base_color_subblock1, pixel_buffer, pbuf_offs, alpha);
			decodeRGBPixelETC1(6, pixel_index_word, table_codeword1, base_color_subblock1, pixel_buffer, pbuf_offs, alpha);
			decodeRGBPixelETC1(7, pixel_index_word, table_codeword1, base_color_subblock1, pixel_buffer, pbuf_offs, alpha);
			decodeRGBPixelETC1(8, pixel_index_word, table_codeword2, base_color_subblock2, pixel_buffer, pbuf_offs, alpha);
			decodeRGBPixelETC1(9, pixel_index_word, table_codeword2, base_color_subblock2, pixel_buffer, pbuf_offs, alpha);
			decodeRGBPixelETC1(10, pixel_index_word, table_codeword2, base_color_subblock2, pixel_buffer, pbuf_offs, alpha);
			decodeRGBPixelETC1(11, pixel_index_word, table_codeword2, base_color_subblock2, pixel_buffer, pbuf_offs, alpha);
			decodeRGBPixelETC1(12, pixel_index_word, table_codeword2, base_color_subblock2, pixel_buffer, pbuf_offs, alpha);
			decodeRGBPixelETC1(13, pixel_index_word, table_codeword2, base_color_subblock2, pixel_buffer, pbuf_offs, alpha);
			decodeRGBPixelETC1(14, pixel_index_word, table_codeword2, base_color_subblock2, pixel_buffer, pbuf_offs, alpha);
			decodeRGBPixelETC1(15, pixel_index_word, table_codeword2, base_color_subblock2, pixel_buffer, pbuf_offs, alpha);
		} else {
			decodeRGBPixelETC1(0, pixel_index_word, table_codeword1, base_color_subblock1, pixel_buffer, pbuf_offs, alpha);
			decodeRGBPixelETC1(1, pixel_index_word, table_codeword1, base_color_subblock1, pixel_buffer, pbuf_offs, alpha);
			decodeRGBPixelETC1(2, pixel_index_word, table_codeword2, base_color_subblock2, pixel_buffer, pbuf_offs, alpha);
			decodeRGBPixelETC1(3, pixel_index_word, table_codeword2, base_color_subblock2, pixel_buffer, pbuf_offs, alpha);
			decodeRGBPixelETC1(4, pixel_index_word, table_codeword1, base_color_subblock1, pixel_buffer, pbuf_offs, alpha);
			decodeRGBPixelETC1(5, pixel_index_word, table_codeword1, base_color_subblock1, pixel_buffer, pbuf_offs, alpha);
			decodeRGBPixelETC1(6, pixel_index_word, table_codeword2, base_color_subblock2, pixel_buffer, pbuf_offs, alpha);
			decodeRGBPixelETC1(7, pixel_index_word, table_codeword2, base_color_subblock2, pixel_buffer, pbuf_offs, alpha);
			decodeRGBPixelETC1(8, pixel_index_word, table_codeword1, base_color_subblock1, pixel_buffer, pbuf_offs, alpha);
			decodeRGBPixelETC1(9, pixel_index_word, table_codeword1, base_color_subblock1, pixel_buffer, pbuf_offs, alpha);
			decodeRGBPixelETC1(10, pixel_index_word, table_codeword2, base_color_subblock2, pixel_buffer, pbuf_offs, alpha);
			decodeRGBPixelETC1(11, pixel_index_word, table_codeword2, base_color_subblock2, pixel_buffer, pbuf_offs, alpha);
			decodeRGBPixelETC1(12, pixel_index_word, table_codeword1, base_color_subblock1, pixel_buffer, pbuf_offs, alpha);
			decodeRGBPixelETC1(13, pixel_index_word, table_codeword1, base_color_subblock1, pixel_buffer, pbuf_offs, alpha);
			decodeRGBPixelETC1(14, pixel_index_word, table_codeword2, base_color_subblock2, pixel_buffer, pbuf_offs, alpha);
			decodeRGBPixelETC1(15, pixel_index_word, table_codeword2, base_color_subblock2, pixel_buffer, pbuf_offs, alpha);
		}
		return true;
	}

	public static final int[] ETC2_DISTANCE_TABLE = new int[]{3, 6, 11, 16, 23, 32, 41, 64};

	private static void processBlockETC2TOrHMode(byte[] bitstring, int bitstring_offs, int mode, byte[] pixel_buffer, int pbuf_offs, boolean alpha) {
		int base_color1_R, base_color1_G, base_color1_B;
		int base_color2_R, base_color2_G, base_color2_B;
		int[] paint_color_R = new int[4];
		int[] paint_color_G = new int[4];
		int[] paint_color_B = new int[4];
		int distance;
		if (mode == DETEX_MODE_MASK_ETC_T) {
			// T mode.
			base_color1_R = ((bitstring[bitstring_offs + 0] & 0x18) >> 1) | (bitstring[bitstring_offs + 0] & 0x3);
			base_color1_R |= base_color1_R << 4;
			base_color1_G = bitstring[bitstring_offs + 1] & 0xF0;
			base_color1_G |= base_color1_G >> 4;
			base_color1_B = bitstring[bitstring_offs + 1] & 0x0F;
			base_color1_B |= base_color1_B << 4;
			base_color2_R = bitstring[bitstring_offs + 2] & 0xF0;
			base_color2_R |= base_color2_R >> 4;
			base_color2_G = bitstring[bitstring_offs + 2] & 0x0F;
			base_color2_G |= base_color2_G << 4;
			base_color2_B = bitstring[bitstring_offs + 3] & 0xF0;
			base_color2_B |= base_color2_B >> 4;
			// index = (da << 1) | db
			distance = ETC2_DISTANCE_TABLE[((bitstring[bitstring_offs + 3] & 0x0C) >> 1) | (bitstring[bitstring_offs + 3] & 0x1)];
			paint_color_R[0] = base_color1_R;
			paint_color_G[0] = base_color1_G;
			paint_color_B[0] = base_color1_B;
			paint_color_R[2] = base_color2_R;
			paint_color_G[2] = base_color2_G;
			paint_color_B[2] = base_color2_B;
			paint_color_R[1] = saturate(base_color2_R + distance);
			paint_color_G[1] = saturate(base_color2_G + distance);
			paint_color_B[1] = saturate(base_color2_B + distance);
			paint_color_R[3] = saturate(base_color2_R - distance);
			paint_color_G[3] = saturate(base_color2_G - distance);
			paint_color_B[3] = saturate(base_color2_B - distance);
		} else {
			// H mode.
			base_color1_R = (bitstring[bitstring_offs + 0] & 0x78) >> 3;
			base_color1_R |= base_color1_R << 4;
			base_color1_G = ((bitstring[bitstring_offs + 0] & 0x07) << 1) | ((bitstring[bitstring_offs + 1] & 0x10) >> 4);
			base_color1_G |= base_color1_G << 4;
			base_color1_B = (bitstring[bitstring_offs + 1] & 0x08) | ((bitstring[bitstring_offs + 1] & 0x03) << 1) | ((bitstring[bitstring_offs + 2] & 0x80) >> 7);
			base_color1_B |= base_color1_B << 4;
			base_color2_R = (bitstring[bitstring_offs + 2] & 0x78) >> 3;
			base_color2_R |= base_color2_R << 4;
			base_color2_G = ((bitstring[bitstring_offs + 2] & 0x07) << 1) | ((bitstring[bitstring_offs + 3] & 0x80) >> 7);
			base_color2_G |= base_color2_G << 4;
			base_color2_B = (bitstring[bitstring_offs + 3] & 0x78) >> 3;
			base_color2_B |= base_color2_B << 4;
			// da is most significant bit, db is middle bit, least significant bit is
			// (base_color1 value >= base_color2 value).
			int base_color1_value = (base_color1_R << 16) + (base_color1_G << 8) + base_color1_B;
			int base_color2_value = (base_color2_R << 16) + (base_color2_G << 8) + base_color2_B;
			int bit;
			if (base_color1_value >= base_color2_value) {
				bit = 1;
			} else {
				bit = 0;
			}
			distance = ETC2_DISTANCE_TABLE[(bitstring[bitstring_offs + 3] & 0x04) | ((bitstring[bitstring_offs + 3] & 0x01) << 1) | bit];
			paint_color_R[0] = saturate(base_color1_R + distance);
			paint_color_G[0] = saturate(base_color1_G + distance);
			paint_color_B[0] = saturate(base_color1_B + distance);
			paint_color_R[1] = saturate(base_color1_R - distance);
			paint_color_G[1] = saturate(base_color1_G - distance);
			paint_color_B[1] = saturate(base_color1_B - distance);
			paint_color_R[2] = saturate(base_color2_R + distance);
			paint_color_G[2] = saturate(base_color2_G + distance);
			paint_color_B[2] = saturate(base_color2_B + distance);
			paint_color_R[3] = saturate(base_color2_R - distance);
			paint_color_G[3] = saturate(base_color2_G - distance);
			paint_color_B[3] = saturate(base_color2_B - distance);
		}
		int pixel_index_word = getPixelIndexWord(bitstring, bitstring_offs);

		for (int i = 0; i < 16; i++) {
			int pixel_index = getPixelIndex(i, pixel_index_word);
			int r = paint_color_R[pixel_index];
			int g = paint_color_G[pixel_index];
			int b = paint_color_B[pixel_index];

			int off = pbuf_offs + ((i & 3) * 4 + ((i & 12) >> 2)) * (alpha ? 4 : 3);
			pixel_buffer[off + 0] = (byte) r;
			pixel_buffer[off + 1] = (byte) g;
			pixel_buffer[off + 2] = (byte) b;
			//System.out.println(r + "/" + g + "/" + b + " at " + off);
			if (alpha) {
				pixel_buffer[off + 3] = (byte) 0xFF;
			}
		}
	}

	private static void processBlockETC2PlanarMode(byte[] bitstring, int bitstring_offs, byte[] pixel_buffer, int pbuf_offs, boolean alpha) {
		// Each color O, H and V is in 6-7-6 format.
		int RO = (bitstring[bitstring_offs + 0] & 0x7E) >> 1;
		int GO = ((bitstring[bitstring_offs + 0] & 0x1) << 6) | ((bitstring[bitstring_offs + 1] & 0x7E) >> 1);
		int BO = ((bitstring[bitstring_offs + 1] & 0x1) << 5) | (bitstring[bitstring_offs + 2] & 0x18) | ((bitstring[bitstring_offs + 2] & 0x03) << 1)
			| ((bitstring[bitstring_offs + 3] & 0x80) >> 7);
		int RH = ((bitstring[bitstring_offs + 3] & 0x7C) >> 1) | (bitstring[bitstring_offs + 3] & 0x1);
		int GH = (bitstring[bitstring_offs + 4] & 0xFE) >> 1;
		int BH = ((bitstring[bitstring_offs + 4] & 0x1) << 5) | ((bitstring[bitstring_offs + 5] & 0xF8) >> 3);
		int RV = ((bitstring[bitstring_offs + 5] & 0x7) << 3) | ((bitstring[bitstring_offs + 6] & 0xE0) >> 5);
		int GV = ((bitstring[bitstring_offs + 6] & 0x1F) << 2) | ((bitstring[bitstring_offs + 7] & 0xC0) >> 6);
		int BV = bitstring[bitstring_offs + 7] & 0x3F;
		RO = (RO << 2) | ((RO & 0x30) >> 4);	// Replicate bits.
		GO = (GO << 1) | ((GO & 0x40) >> 6);
		BO = (BO << 2) | ((BO & 0x30) >> 4);
		RH = (RH << 2) | ((RH & 0x30) >> 4);
		GH = (GH << 1) | ((GH & 0x40) >> 6);
		BH = (BH << 2) | ((BH & 0x30) >> 4);
		RV = (RV << 2) | ((RV & 0x30) >> 4);
		GV = (GV << 1) | ((GV & 0x40) >> 6);
		BV = (BV << 2) | ((BV & 0x30) >> 4);

		for (int y = 0; y < 4; y++) {
			for (int x = 0; x < 4; x++) {
				int r = saturate((x * (RH - RO) + y * (RV - RO) + 4 * RO + 2) >> 2);
				int g = saturate((x * (GH - GO) + y * (GV - GO) + 4 * GO + 2) >> 2);
				int b = saturate((x * (BH - BO) + y * (BV - BO) + 4 * BO + 2) >> 2);
				int off = pbuf_offs + (y * 4 + x) * (alpha ? 4 : 3);
				pixel_buffer[off + 0] = (byte) r;
				pixel_buffer[off + 1] = (byte) g;
				pixel_buffer[off + 2] = (byte) b;

				if (alpha) {
					pixel_buffer[off + 3] = (byte) 0xFF;
				}
			}
		}
	}

	/**
	 * Decompress a 64-bit 4x4 pixel texture block compressed using the ETC2 format.
	 *
	 * @param bitstring Byte array containing the texture block.
	 * @param bitstring_offs Offset of the texture block in the array.
	 * @param mode_mask Mask of enabled decoding modes.
	 * @param flags Detex decompression cap flags.
	 * @param pixel_buffer Output RGBA buffer.
	 * @param pbuf_offs Offset of the resulting block in the RGBA buffer.
	 * @param alpha True if the target buffer is a 4BPP RGBA image instead of 3BPP RGB.
	 *
	 * @return True if the entire block was successfully decoded.
	 */
	public static boolean detexDecompressBlockETC2(byte[] bitstring, int bitstring_offs, int mode_mask, int flags, byte[] pixel_buffer, int pbuf_offs, boolean alpha) {
		// Figure out the mode.
		if ((bitstring[bitstring_offs + 3] & 2) == 0) {
			// Individual mode.
			return detexDecompressBlockETC1(bitstring, bitstring_offs, mode_mask, flags, pixel_buffer, pbuf_offs, alpha);
		}
		if ((mode_mask & (~DETEX_MODE_MASK_ETC_INDIVIDUAL)) == 0) {
			return false;
		}
		int R = (bitstring[bitstring_offs + 0] & 0xF8);
		R += complement3bitshifted(bitstring[bitstring_offs + 0] & 7);
		int G = (bitstring[bitstring_offs + 1] & 0xF8);
		G += complement3bitshifted(bitstring[bitstring_offs + 1] & 7);
		int B = (bitstring[bitstring_offs + 2] & 0xF8);
		B += complement3bitshifted(bitstring[bitstring_offs + 2] & 7);
		if ((R & 0xFF07) != 0) {
			// T mode.
			if ((mode_mask & DETEX_MODE_MASK_ETC_T) == 0) {
				return false;
			}
			processBlockETC2TOrHMode(bitstring, bitstring_offs, DETEX_MODE_MASK_ETC_T, pixel_buffer, pbuf_offs, alpha);
			return true;
		} else if ((G & 0xFF07) != 0) {
			// H mode.
			if ((mode_mask & DETEX_MODE_MASK_ETC_H) == 0) {
				return false;
			}
			processBlockETC2TOrHMode(bitstring, bitstring_offs, DETEX_MODE_MASK_ETC_H, pixel_buffer, pbuf_offs, alpha);
			return true;
		} else if ((B & 0xFF07) != 0) {
			// Planar mode.
			if ((mode_mask & DETEX_MODE_MASK_ETC_PLANAR) == 0) {
				return false;
			}
			processBlockETC2PlanarMode(bitstring, bitstring_offs, pixel_buffer, pbuf_offs, alpha);
			return true;
		} else {
			// Differential mode.
			return detexDecompressBlockETC1(bitstring, bitstring_offs, mode_mask, flags, pixel_buffer, pbuf_offs, alpha);
		}
	}

	private static final int[][] PUNCHTHROUGH_MODIFIER_TABLE = new int[][]{
		{0, 8, 0, -8},
		{0, 17, 0, -17},
		{0, 29, 0, -29},
		{0, 42, 0, -42},
		{0, 60, 0, -60},
		{0, 80, 0, -80},
		{0, 106, 0, -106},
		{0, 183, 0, -183}
	};

	private static final int[] punchthrough_mask_table = new int[]{
		0xFFFFFFFF, 0xFFFFFFFF, 0x00000000, 0xFFFFFFFF};

	private static void processPixelETC2Punchthrough(int i, int pixel_index_word, int table_codeword, int[] base_color_subblock, byte[] pixel_buffer, int pbuf_offs) {
		int pixel_index = getPixelIndex(i, pixel_index_word);
		int r, g, b;
		int modifier = PUNCHTHROUGH_MODIFIER_TABLE[table_codeword][pixel_index];
		r = saturate(base_color_subblock[0] + modifier);
		g = saturate(base_color_subblock[1] + modifier);
		b = saturate(base_color_subblock[2] + modifier);
		int mask = punchthrough_mask_table[pixel_index];
		int off = pbuf_offs + ((i & 3) * 4 + ((i & 12) >> 2)) * 4;

		if (mask != 0) {
			pixel_buffer[off + 0] = (byte) r;
			pixel_buffer[off + 1] = (byte) g;
			pixel_buffer[off + 2] = (byte) b;
			pixel_buffer[off + 3] = (byte) 0xFF;
		}
	}

	private static void processBlockETC2PunchthroughDifferentialMode(byte[] bitstring, int bitstring_offs, byte[] pixel_buffer, int pbuf_offs) {
		int flipbit = bitstring[bitstring_offs + 3] & 1;
		int[] base_color_subblock1 = new int[3];
		int[] base_color_subblock2 = new int[8];
		base_color_subblock1[0] = (bitstring[bitstring_offs + 0] & 0xF8);
		base_color_subblock1[0] |= ((base_color_subblock1[0] & 224) >> 5);
		base_color_subblock1[1] = (bitstring[bitstring_offs + 1] & 0xF8);
		base_color_subblock1[1] |= (base_color_subblock1[1] & 224) >> 5;
		base_color_subblock1[2] = (bitstring[bitstring_offs + 2] & 0xF8);
		base_color_subblock1[2] |= (base_color_subblock1[2] & 224) >> 5;
		base_color_subblock2[0] = (bitstring[bitstring_offs + 0] & 0xF8);				// 5 highest order bits.
		base_color_subblock2[0] += complement3bitshifted(bitstring[bitstring_offs + 0] & 7);	// Add difference.
		base_color_subblock2[0] |= (base_color_subblock2[0] & 224) >> 5;		// Replicate.
		base_color_subblock2[1] = (bitstring[bitstring_offs + 1] & 0xF8);
		base_color_subblock2[1] += complement3bitshifted(bitstring[bitstring_offs + 1] & 7);
		base_color_subblock2[1] |= (base_color_subblock2[1] & 224) >> 5;
		base_color_subblock2[2] = (bitstring[bitstring_offs + 2] & 0xF8);
		base_color_subblock2[2] += complement3bitshifted(bitstring[bitstring_offs + 2] & 7);
		base_color_subblock2[2] |= (base_color_subblock2[2] & 224) >> 5;
		int table_codeword1 = (bitstring[bitstring_offs + 3] & 224) >> 5;
		int table_codeword2 = (bitstring[bitstring_offs + 3] & 28) >> 2;
		int pixel_index_word = getPixelIndexWord(bitstring, bitstring_offs);
		if (flipbit == 0) {
			processPixelETC2Punchthrough(0, pixel_index_word, table_codeword1, base_color_subblock1, pixel_buffer, pbuf_offs);
			processPixelETC2Punchthrough(1, pixel_index_word, table_codeword1, base_color_subblock1, pixel_buffer, pbuf_offs);
			processPixelETC2Punchthrough(2, pixel_index_word, table_codeword1, base_color_subblock1, pixel_buffer, pbuf_offs);
			processPixelETC2Punchthrough(3, pixel_index_word, table_codeword1, base_color_subblock1, pixel_buffer, pbuf_offs);
			processPixelETC2Punchthrough(4, pixel_index_word, table_codeword1, base_color_subblock1, pixel_buffer, pbuf_offs);
			processPixelETC2Punchthrough(5, pixel_index_word, table_codeword1, base_color_subblock1, pixel_buffer, pbuf_offs);
			processPixelETC2Punchthrough(6, pixel_index_word, table_codeword1, base_color_subblock1, pixel_buffer, pbuf_offs);
			processPixelETC2Punchthrough(7, pixel_index_word, table_codeword1, base_color_subblock1, pixel_buffer, pbuf_offs);
			processPixelETC2Punchthrough(8, pixel_index_word, table_codeword2, base_color_subblock2, pixel_buffer, pbuf_offs);
			processPixelETC2Punchthrough(9, pixel_index_word, table_codeword2, base_color_subblock2, pixel_buffer, pbuf_offs);
			processPixelETC2Punchthrough(10, pixel_index_word, table_codeword2, base_color_subblock2, pixel_buffer, pbuf_offs);
			processPixelETC2Punchthrough(11, pixel_index_word, table_codeword2, base_color_subblock2, pixel_buffer, pbuf_offs);
			processPixelETC2Punchthrough(12, pixel_index_word, table_codeword2, base_color_subblock2, pixel_buffer, pbuf_offs);
			processPixelETC2Punchthrough(13, pixel_index_word, table_codeword2, base_color_subblock2, pixel_buffer, pbuf_offs);
			processPixelETC2Punchthrough(14, pixel_index_word, table_codeword2, base_color_subblock2, pixel_buffer, pbuf_offs);
			processPixelETC2Punchthrough(15, pixel_index_word, table_codeword2, base_color_subblock2, pixel_buffer, pbuf_offs);
		} else {
			processPixelETC2Punchthrough(0, pixel_index_word, table_codeword1, base_color_subblock1, pixel_buffer, pbuf_offs);
			processPixelETC2Punchthrough(1, pixel_index_word, table_codeword1, base_color_subblock1, pixel_buffer, pbuf_offs);
			processPixelETC2Punchthrough(2, pixel_index_word, table_codeword2, base_color_subblock2, pixel_buffer, pbuf_offs);
			processPixelETC2Punchthrough(3, pixel_index_word, table_codeword2, base_color_subblock2, pixel_buffer, pbuf_offs);
			processPixelETC2Punchthrough(4, pixel_index_word, table_codeword1, base_color_subblock1, pixel_buffer, pbuf_offs);
			processPixelETC2Punchthrough(5, pixel_index_word, table_codeword1, base_color_subblock1, pixel_buffer, pbuf_offs);
			processPixelETC2Punchthrough(6, pixel_index_word, table_codeword2, base_color_subblock2, pixel_buffer, pbuf_offs);
			processPixelETC2Punchthrough(7, pixel_index_word, table_codeword2, base_color_subblock2, pixel_buffer, pbuf_offs);
			processPixelETC2Punchthrough(8, pixel_index_word, table_codeword1, base_color_subblock1, pixel_buffer, pbuf_offs);
			processPixelETC2Punchthrough(9, pixel_index_word, table_codeword1, base_color_subblock1, pixel_buffer, pbuf_offs);
			processPixelETC2Punchthrough(10, pixel_index_word, table_codeword2, base_color_subblock2, pixel_buffer, pbuf_offs);
			processPixelETC2Punchthrough(11, pixel_index_word, table_codeword2, base_color_subblock2, pixel_buffer, pbuf_offs);
			processPixelETC2Punchthrough(12, pixel_index_word, table_codeword1, base_color_subblock1, pixel_buffer, pbuf_offs);
			processPixelETC2Punchthrough(13, pixel_index_word, table_codeword1, base_color_subblock1, pixel_buffer, pbuf_offs);
			processPixelETC2Punchthrough(14, pixel_index_word, table_codeword2, base_color_subblock2, pixel_buffer, pbuf_offs);
			processPixelETC2Punchthrough(15, pixel_index_word, table_codeword2, base_color_subblock2, pixel_buffer, pbuf_offs);
		}
	}

	private static void processBlockETC2PunchthroughTOrHMode(byte[] bitstring, int bitstring_offs, int mode, byte[] pixel_buffer, int pbuf_offs) {
		int base_color1_R, base_color1_G, base_color1_B;
		int base_color2_R, base_color2_G, base_color2_B;
		int[] paint_color_R = new int[4];
		int[] paint_color_G = new int[4];
		int[] paint_color_B = new int[4];
		int distance;
		if (mode == DETEX_MODE_MASK_ETC_T) {
			// T mode.
			base_color1_R = ((bitstring[bitstring_offs + 0] & 0x18) >> 1) | (bitstring[bitstring_offs + 0] & 0x3);
			base_color1_R |= base_color1_R << 4;
			base_color1_G = bitstring[bitstring_offs + 1] & 0xF0;
			base_color1_G |= base_color1_G >> 4;
			base_color1_B = bitstring[bitstring_offs + 1] & 0x0F;
			base_color1_B |= base_color1_B << 4;
			base_color2_R = bitstring[bitstring_offs + 2] & 0xF0;
			base_color2_R |= base_color2_R >> 4;
			base_color2_G = bitstring[bitstring_offs + 2] & 0x0F;
			base_color2_G |= base_color2_G << 4;
			base_color2_B = bitstring[bitstring_offs + 3] & 0xF0;
			base_color2_B |= base_color2_B >> 4;
			// index = (da << 1) | db
			distance = ETC2_DISTANCE_TABLE[((bitstring[bitstring_offs + 3] & 0x0C) >> 1) | (bitstring[bitstring_offs + 3] & 0x1)];
			paint_color_R[0] = base_color1_R;
			paint_color_G[0] = base_color1_G;
			paint_color_B[0] = base_color1_B;
			paint_color_R[2] = base_color2_R;
			paint_color_G[2] = base_color2_G;
			paint_color_B[2] = base_color2_B;
			paint_color_R[1] = saturate(base_color2_R + distance);
			paint_color_G[1] = saturate(base_color2_G + distance);
			paint_color_B[1] = saturate(base_color2_B + distance);
			paint_color_R[3] = saturate(base_color2_R - distance);
			paint_color_G[3] = saturate(base_color2_G - distance);
			paint_color_B[3] = saturate(base_color2_B - distance);
		} else {
			// H mode.
			base_color1_R = (bitstring[bitstring_offs + 0] & 0x78) >> 3;
			base_color1_R |= base_color1_R << 4;
			base_color1_G = ((bitstring[bitstring_offs + 0] & 0x07) << 1) | ((bitstring[bitstring_offs + 1] & 0x10) >> 4);
			base_color1_G |= base_color1_G << 4;
			base_color1_B = (bitstring[bitstring_offs + 1] & 0x08) | ((bitstring[bitstring_offs + 1] & 0x03) << 1) | ((bitstring[bitstring_offs + 2] & 0x80) >> 7);
			base_color1_B |= base_color1_B << 4;
			base_color2_R = (bitstring[bitstring_offs + 2] & 0x78) >> 3;
			base_color2_R |= base_color2_R << 4;
			base_color2_G = ((bitstring[bitstring_offs + 2] & 0x07) << 1) | ((bitstring[bitstring_offs + 3] & 0x80) >> 7);
			base_color2_G |= base_color2_G << 4;
			base_color2_B = (bitstring[bitstring_offs + 3] & 0x78) >> 3;
			base_color2_B |= base_color2_B << 4;
			// da is most significant bit, db is middle bit, least significant bit is
			// (base_color1 value >= base_color2 value).
			int base_color1_value = (base_color1_R << 16) + (base_color1_G << 8) + base_color1_B;
			int base_color2_value = (base_color2_R << 16) + (base_color2_G << 8) + base_color2_B;
			int bit;
			if (base_color1_value >= base_color2_value) {
				bit = 1;
			} else {
				bit = 0;
			}
			distance = ETC2_DISTANCE_TABLE[(bitstring[bitstring_offs + 3] & 0x04) | ((bitstring[bitstring_offs + 3] & 0x01) << 1) | bit];
			paint_color_R[0] = saturate(base_color1_R + distance);
			paint_color_G[0] = saturate(base_color1_G + distance);
			paint_color_B[0] = saturate(base_color1_B + distance);
			paint_color_R[1] = saturate(base_color1_R - distance);
			paint_color_G[1] = saturate(base_color1_G - distance);
			paint_color_B[1] = saturate(base_color1_B - distance);
			paint_color_R[2] = saturate(base_color2_R + distance);
			paint_color_G[2] = saturate(base_color2_G + distance);
			paint_color_B[2] = saturate(base_color2_B + distance);
			paint_color_R[3] = saturate(base_color2_R - distance);
			paint_color_G[3] = saturate(base_color2_G - distance);
			paint_color_B[3] = saturate(base_color2_B - distance);
		}
		int pixel_index_word = getPixelIndexWord(bitstring, bitstring_offs);

		for (int i = 0; i < 16; i++) {
			int pixel_index = getPixelIndex(i, pixel_index_word);
			int r = paint_color_R[pixel_index];
			int g = paint_color_G[pixel_index];
			int b = paint_color_B[pixel_index];

			int off = pbuf_offs + ((i & 3) * 4 + ((i & 12) >> 2)) * 4;

			int mask = punchthrough_mask_table[pixel_index];
			if (mask != 0) {
				pixel_buffer[off + 0] = (byte) r;
				pixel_buffer[off + 1] = (byte) g;
				pixel_buffer[off + 2] = (byte) b;
				pixel_buffer[off + 3] = (byte) 0xFF;
			}
		}
	}

	/**
	 * Decompress a 64-bit 4x4 pixel texture block compressed using the ETC2_PUNCHTHROUGH format.
	 *
	 * @param bitstring Byte array containing the texture block.
	 * @param bitstring_offs Offset of the texture block in the array.
	 * @param mode_mask Mask of enabled decoding modes.
	 * @param flags Detex decompression cap flags.
	 * @param pixel_buffer Output RGBA buffer.
	 * @param pbuf_offs Offset of the resulting block in the RGBA buffer.
	 *
	 * @return True if the entire block was successfully decoded.
	 */
	public static boolean detexDecompressBlockETC2_PUNCHTHROUGH(byte[] bitstring, int bitstring_offs, int mode_mask, int flags, byte[] pixel_buffer, int pbuf_offs) {
		int R = (bitstring[bitstring_offs + 0] & 0xF8);
		R += complement3bitshifted(bitstring[bitstring_offs + 0] & 7);
		int G = (bitstring[bitstring_offs + 1] & 0xF8);
		G += complement3bitshifted(bitstring[bitstring_offs + 1] & 7);
		int B = (bitstring[bitstring_offs + 2] & 0xF8);
		B += complement3bitshifted(bitstring[bitstring_offs + 2] & 7);
		boolean opaque = (bitstring[bitstring_offs + 3] & 2) != 0;
		if (opaque && (flags & DETEX_DECOMPRESS_FLAG_NON_OPAQUE_ONLY) != 0) {
			return false;
		}
		if (!opaque && (flags & DETEX_DECOMPRESS_FLAG_OPAQUE_ONLY) != 0) {
			return false;
		}
		if ((R & 0xFF07) != 0) {
			// T mode.
			if ((mode_mask & DETEX_MODE_MASK_ETC_T) == 0) {
				return false;
			}
			if (opaque) {
				processBlockETC2TOrHMode(bitstring, bitstring_offs, DETEX_MODE_MASK_ETC_T, pixel_buffer, pbuf_offs, true);
				return true;
			}
			// T mode with punchthrough alpha.
			processBlockETC2PunchthroughTOrHMode(bitstring, bitstring_offs, DETEX_MODE_MASK_ETC_T, pixel_buffer, pbuf_offs);
			return true;
		} else if ((G & 0xFF07) != 0) {
			// H mode.
			if ((mode_mask & DETEX_MODE_MASK_ETC_H) == 0) {
				return false;
			}
			if (opaque) {
				processBlockETC2TOrHMode(bitstring, bitstring_offs, DETEX_MODE_MASK_ETC_H, pixel_buffer, pbuf_offs, true);
				return true;
			}
			// H mode with punchthrough alpha.
			processBlockETC2PunchthroughTOrHMode(bitstring, bitstring_offs, DETEX_MODE_MASK_ETC_H, pixel_buffer, pbuf_offs);
			return true;
		} else if ((B & 0xFF07) != 0) {
			// Planar mode.
			if ((mode_mask & DETEX_MODE_MASK_ETC_PLANAR) == 0) {
				return false;
			}
			// Opaque always set.
			if ((flags & DETEX_DECOMPRESS_FLAG_NON_OPAQUE_ONLY) != 0) {
				return false;
			}
			processBlockETC2PlanarMode(bitstring, bitstring_offs, pixel_buffer, pbuf_offs, true);
			return true;
		} else {
			// Differential mode.
			if (opaque) {
				return detexDecompressBlockETC1(bitstring, bitstring_offs, mode_mask, flags, pixel_buffer, pbuf_offs, true);
			}
			// Differential mode with punchthrough alpha.
			if ((mode_mask & DETEX_MODE_MASK_ETC_DIFFERENTIAL) == 0) {
				return false;
			}
			processBlockETC2PunchthroughDifferentialMode(bitstring, bitstring_offs, pixel_buffer, pbuf_offs);
			return true;
		}
	}


	/* Return the internal mode of a ETC2_PUNCHTROUGH block. */
	public static int detexGetModeETC2_PUNCHTHROUGH(byte[] bitstring, int bitstring_offs) {
		// Figure out the mode.
//	int opaque = bitstring[3] & 2;
		int R = (bitstring[bitstring_offs + 0] & 0xF8);
		R += complement3bitshifted(bitstring[bitstring_offs + 0] & 7);
		int G = (bitstring[bitstring_offs + 1] & 0xF8);
		G += complement3bitshifted(bitstring[bitstring_offs + 1] & 7);
		int B = (bitstring[bitstring_offs + 2] & 0xF8);
		B += complement3bitshifted(bitstring[bitstring_offs + 2] & 7);
		if ((R & 0xFF07) != 0) // T mode.
		{
			return 2;
		} else if ((G & 0xFF07) != 0) // H mode.
		{
			return 3;
		} else if ((B & 0xFF07) != 0) // Planar mode.
		{
			return 4;
		} else // Differential mode.
		{
			return 1;
		}
	}

	public static byte[] etc2Decode(byte[] data, int width, int height) {
		byte[] output = new byte[3 * width * height];

		int alignedWidth = TextureCodec.nlpo2(width);
		int alignedHeight = TextureCodec.nlpo2(height);

		byte[] temp = new byte[3 * 16];

		int hib = alignedHeight / 4;
		int wib = alignedWidth / 4;

		int dataOff = 0;

		for (int y = 0; y < hib; y++) {
			int nu_rows;
			if (y * 4 + 3 >= alignedHeight) {
				nu_rows = alignedHeight - y * 4;
			} else {
				nu_rows = 4;
			}
			for (int x = 0; x < wib; x++) {
				if (detexDecompressBlockETC2(data, dataOff, DETEX_MODE_MASK_ALL, 0, temp, 0, false)) {
					int pixelOff = y * 4 * alignedWidth * 3 + x * 4 * 3;
					int nu_columns;
					if (x * 4 + 3 >= alignedWidth) {
						nu_columns = alignedWidth - x * 4;
					} else {
						nu_columns = 4;
					}
					for (int row = 0; row < nu_rows; row++) {
						System.arraycopy(temp, row * 4 * 3, output, pixelOff + row * alignedWidth * 3, nu_columns * 3);
					}
				}

				dataOff += 8;
			}
		}

		return output;
	}

	public static byte[] etc2DecodePunchthrough(byte[] data, int width, int height) {
		byte[] output = new byte[4 * width * height];

		int alignedWidth = TextureCodec.nlpo2(width);
		int alignedHeight = TextureCodec.nlpo2(height);

		byte[] temp = new byte[4 * 16];

		int hib = alignedHeight / 4;
		int wib = alignedWidth / 4;

		int dataOff = 0;

		for (int y = 0; y < hib; y++) {
			int nu_rows;
			if (y * 4 + 3 >= alignedHeight) {
				nu_rows = alignedHeight - y * 4;
			} else {
				nu_rows = 4;
			}
			for (int x = 0; x < wib; x++) {
				detexDecompressBlockETC2_PUNCHTHROUGH(data, dataOff, DETEX_MODE_MASK_ALL, 0, temp, 0);

				int pixelOff = y * 4 * alignedWidth * 4 + x * 4 * 4;
				int nu_columns;
				if (x * 4 + 3 >= alignedWidth) {
					nu_columns = alignedWidth - x * 4;
				} else {
					nu_columns = 4;
				}
				for (int row = 0; row < nu_rows; row++) {
					System.arraycopy(temp, row * 4 * 4, output, pixelOff + row * alignedWidth * 4, nu_columns * 4);
				}
				dataOff += 8;
			}
		}

		return output;
	}

	public static byte[] etc2DecodeEAC(byte[] data, int width, int height) {
		byte[] output = new byte[4 * width * height];

		int alignedWidth = TextureCodec.nlpo2(width);
		int alignedHeight = TextureCodec.nlpo2(height);

		byte[] temp = new byte[4 * 16];

		int hib = alignedHeight / 4;
		int wib = alignedWidth / 4;

		int dataOff = 0;

		for (int y = 0; y < hib; y++) {
			int nu_rows;
			if (y * 4 + 3 >= alignedHeight) {
				nu_rows = alignedHeight - y * 4;
			} else {
				nu_rows = 4;
			}
			for (int x = 0; x < wib; x++) {
				EAC.detexDecompressBlockETC2_EAC(data, dataOff, DETEX_MODE_MASK_ALL, 0, temp, 0);

				int pixelOff = y * 4 * alignedWidth * 4 + x * 4 * 4;
				int nu_columns;
				if (x * 4 + 3 >= alignedWidth) {
					nu_columns = alignedWidth - x * 4;
				} else {
					nu_columns = 4;
				}
				for (int row = 0; row < nu_rows; row++) {
					System.arraycopy(temp, row * 4 * 4, output, pixelOff + row * alignedWidth * 4, nu_columns * 4);
				}
				dataOff += 16;
			}
		}
		return output;
	}
}
